import torch
from transformers import RobertaTokenizer, RobertaForSequenceClassification

# Load the fine-tuned model and tokenizer
model = RobertaForSequenceClassification.from_pretrained(
    '../models/vulnerability_detection_codebert')
tokenizer = RobertaTokenizer.from_pretrained(
    '../models/vulnerability_detection_codebert')


# Define a function to classify a Java code snippet
def classify_code(code):
    # Tokenize the input code
    inputs = tokenizer(code, padding='max_length', truncation=True, return_tensors="pt")

    # Get model predictions
    with torch.no_grad():
        outputs = model(**inputs)

    # Get predicted label
    logits = outputs.logits
    predicted_class_id = torch.argmax(logits, dim=-1).item()

    return predicted_class_id


# Example Java code snippet
example_code = """
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class SQLInjectionExample {
    public static void main(String[] args) {
        String userInput = "1 OR 1=1";
        try {
            Connection connection = DriverManager.getConnection("jdbc:your_database_url", "username", "password");
            String query = "SELECT * FROM users WHERE id = " + userInput;
            PreparedStatement statement = connection.prepareStatement(query);
            statement.executeQuery();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
"""

# Make a prediction
predicted_label_id = classify_code(example_code)

# Map label id back to label
vulnerability_set = [
    'hardcoded_credentials',
    'insecure_data_storage',
    'sql_injection',
    'insecure_random',
    'insecure_file_permissions',
    'memory_leaks',
    'lack_of_data_obfuscation',
    'lack_of_hashing'
]
predicted_label = vulnerability_set[predicted_label_id]

print(f"Predicted vulnerability label: {predicted_label}")
