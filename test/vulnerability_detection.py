import torch
from transformers import RobertaTokenizer, RobertaForSequenceClassification

# Load the fine-tuned model and tokenizer
model = RobertaForSequenceClassification.from_pretrained('../models/vulnerability_detection_codebert')
tokenizer = RobertaTokenizer.from_pretrained('../models/vulnerability_detection_codebert')

# Define a function to classify a Java code snippet
def classify_code(code):
    # Tokenize the input code
    inputs = tokenizer(code, padding='max_length', truncation=True, return_tensors="pt")

    # Get model predictions
    with torch.no_grad():
        outputs = model(**inputs)

    # Get predicted label
    logits = outputs.logits
    predicted_class_id = torch.argmax(logits, dim=-1).item()

    return predicted_class_id


# Example Java code snippet
java_code = """
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class SQLInjectionExample {
    public static void main(String[] args) {
        String userInput = "1 OR 1=1";
        try {
            Connection connection = DriverManager.getConnection("jdbc:your_database_url", "username", "password");
            String query = "SELECT * FROM users WHERE id = " + userInput;
            PreparedStatement statement = connection.prepareStatement(query);
            statement.executeQuery();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
"""

dart_code = """
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('Rooted Device Access Check')),
        body: Center(
          child: RootCheckButton(),
        ),
      ),
    );
  }
}

class RootCheckButton extends StatelessWidget {
  static const platform = MethodChannel('com.example/root_check');

  Future<void> _checkRoot() async {
    try {
      final bool isRooted = await platform.invokeMethod('isRooted');
      if (isRooted) {
        print('Device is rooted');
      } else {
        print('Device is not rooted');
      }
    } on PlatformException catch (e) {
      print("Failed to check root status: '${e.message}'.");
    }
  }

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: _checkRoot,
      child: Text('Check if Device is Rooted'),
    );
  }
}
"""

# Make a prediction
java_predicted_label_id = classify_code(java_code)
dart_predicted_label_id = classify_code(dart_code)

# Map label id back to label
vulnerability_set = [
    'hardcoded_credentials',
    'insecure_data_storage',
    'sql_injection',
    'insecure_random',
    'insecure_file_permissions',
    'memory_leaks',
    'lack_of_data_obfuscation',
    'lack_of_hashing',
    'rooted_device_access',
    'no_vulnerability'
]
java_predicted_label = vulnerability_set[java_predicted_label_id]
dart_predicted_label = vulnerability_set[dart_predicted_label_id]

print(f"Java predicted vulnerability label: {java_predicted_label}")
print(f"Dart predicted vulnerability label: {dart_predicted_label}")
